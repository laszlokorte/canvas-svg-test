<!DOCTYPE html>
<html>
	<head>
    <meta charset="utf-8" />
		<title>FSM per Canvas</title>
    <link rel="stylesheet" href="style.css" />

	</head>
	<body>
    <h1>Canvas</h1>

    <canvas id="stage" width="800" height="600">
      Eine Final State Machine
    </canvas>

    <div class="explaination">
      <p>
        The graph above is drawn on a canvas.
      </p>
      <p>
        You can move the state bubbles by dragging them with your mouse.
      </p>
      <p>
        Move the camera by dragging the background.
      </p>
      <h3>Advantages</h3>
      <ul>
        <li>more control over the exact rendering procedure (?)</li>
      </ul>

      <h3>Disadvantages</h3>
      <ul>
        <li>hittest for elements needs to be done manually</li>
      </ul>
    </div>

    <script type="text/javascript" src="common.js"></script>
    <script type="text/javascript">
      var setup = function(stage) {
        var states = loadFSM();
        var cam = createCamera();

        var renderState = function(ctx, state, active) {
          ctx.beginPath();
          ctx.arc(state.pos.x, state.pos.y, 70, 0, 2 * Math.PI, false);
          ctx.fillStyle = 'lightgrey';
          ctx.fill();
          ctx.lineWidth = active ? 10 : 5;
          ctx.strokeStyle = 'darkgrey';
          ctx.stroke();

          ctx.fillStyle = 'black';
          ctx.font = "30pt Arial";
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(state.name,state.pos.x,state.pos.y);
        };

        var renderTransition = function(ctx, source, target, label, preferredAngle) {
          var curve = curvedConnection(source.pos, target.pos, 80, preferredAngle);

          var arrowHead = curveArrowHead(curve, 50);

          ctx.beginPath();
          ctx.moveTo(curve[0], curve[1]);
          ctx.bezierCurveTo(
            curve[0]+curve[2],
            curve[1]+curve[3],
            curve[0]+curve[4],
            curve[1]+curve[5],
            curve[0]+curve[6],
            curve[1]+curve[7]
          );

          ctx.strokeStyle = 'green';
          ctx.lineWidth = 8;

          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(arrowHead[0], arrowHead[1]);
          ctx.lineTo(arrowHead[2], arrowHead[3]);
          ctx.lineTo(arrowHead[4], arrowHead[5]);

          ctx.fillStyle = 'green';
          ctx.fill();

          var aligns = ['left','center','right'];
          var textPosition = curveLabelPosition(curve, 30);
          ctx.font = "25pt Arial";
          ctx.textAlign = aligns[1+textPosition.align];
          ctx.textBaseline = 'middle';
          ctx.fillText(label,textPosition.x,textPosition.y);
        };

        var doRender = function() {
          var ctx = stage.getContext('2d');
          var width = parseInt(stage.getAttribute('width'), 10);
          var height = parseInt(stage.getAttribute('height'), 10);

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, width, height);

          ctx.translate(
            width/2,
            height/2
          );
          ctx.scale(cam.zoom, cam.zoom);

          ctx.translate(
            -cam.x,
            -cam.y
          );
          states.forEach(function(state, i) {
            renderState(ctx, state,
              dragState.activeState === i);
          });

          states.forEach(function(state, stateIdx) {
            var connectionPivotAngle = calculateTransitionPivotAngle(states, stateIdx);

            state.transitions.forEach(function(transition) {
              var target = states[transition.target];
              renderTransition(ctx, state, target, ''+transition.condition, connectionPivotAngle + Math.PI);
            });
          });
        };

        var render = makeRenderer(doRender);

        var eventToCursorPosition = function(evt){
          var rect = stage.getBoundingClientRect();
          var leftPercent = (evt.clientX - rect.left) / (rect.right - rect.left);
          var topPercent = (evt.clientY - rect.top) / (rect.bottom - rect.top);

          return {
            x: cam.x + (leftPercent * stage.width) / cam.zoom
               - stage.width/2 / cam.zoom,
            y: cam.y + (topPercent * stage.height) / cam.zoom
            - stage.height/2 / cam.zoom
          };
        }

        var onDragStart = render;
        var onDragEnd = render;

        var panHandler = createPanHandler(cam, render, 1200, 600);
        var onDragMove = createDragMoveHandler(states, render, panHandler);

        var hitTest = function(evt, pos) {
          return states.reduce(function(prev, curr, idx) {
            return vecDistance(pos, curr.pos) < 80 ? idx : prev;
          }, -1);
        };

        var onZoom = createZoomHandler(cam, render, 0.3, 3, panHandler);

        var onDoubleClick = function() {
          arangeStates(states);
          cam.zoom = 0.7;
          cam.x = 0;
          cam.y = 0;

          render();
        };

        var dragState = setupMouseHandler(stage, eventToCursorPosition, hitTest, onDragStart, onDragMove, onDragEnd, onZoom, onDoubleClick);

        return function() {
          setStageSize(stage, 1200, 600);
          render();
        };
      }

      var renderer = setup(document.getElementById('stage'));
      renderer();
    </script>
	</body>
</html>
