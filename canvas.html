<!DOCTYPE html>
<html>
	<head>
    <meta charset="utf-8" />
		<title>FSM per Canvas</title>
    <link rel="stylesheet" href="style.css" />

	</head>
	<body>
    <h1>Canvas</h1>

    <canvas id="stage" width="800" height="600">
      Eine Final State Machine
    </canvas>

    <div class="explaination">
      <p>
        The graph above is drawn on a canvas.
      </p>
      <p>
        You can move the state bubbles by dragging them with your mouse.
      </p>
      <h3>Advantages</h3>
      <ul>
        <li>more control over the exact rendering procedure (?)</li>
      </ul>

      <h3>Disadvantages</h3>
      <ul>
        <li>hittest for elements needs to be done manually</li>
      </ul>
    </div>

    <script type="text/javascript" src="common.js"></script>
    <script type="text/javascript">
      var setup = function(stage) {
        var states = loadFSM();

        var renderState = function(ctx, state, active) {
          ctx.beginPath();
          ctx.arc(state.pos.x, state.pos.y, 70, 0, 2 * Math.PI, false);
          ctx.fillStyle = 'lightgrey';
          ctx.fill();
          ctx.lineWidth = active ? 10 : 5;
          ctx.strokeStyle = 'darkgrey';
          ctx.stroke();
        };

        var renderTransition = function(ctx, source, target) {
          var curve = curvedConnection(source.pos, target.pos, 80);

          var arrowHead = curveArrowHead(curve, 50);

          ctx.beginPath();
          ctx.moveTo(curve[0], curve[1]);
          ctx.quadraticCurveTo(
            curve[0]+curve[2],
            curve[1]+curve[3],
            curve[0]+curve[4],
            curve[1]+curve[5]
          );

          ctx.strokeStyle = 'green';
          ctx.lineWidth = 8;

          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(arrowHead[0], arrowHead[1]);
          ctx.lineTo(arrowHead[2], arrowHead[3]);
          ctx.lineTo(arrowHead[4], arrowHead[5]);

          ctx.fillStyle = 'green';
          ctx.fill();
        };

        var render = function() {
          var ctx = stage.getContext('2d');
          var width = stage.getAttribute('width');
          var height = stage.getAttribute('height');

          ctx.clearRect(0, 0, width, height);

          states.forEach(function(state, i) {
            renderState(ctx, state,
              dragState.activeState === i);
          });

          states.forEach(function(state) {
            state.transitions.forEach(function(transition) {
              var target = states[transition.target];
              renderTransition(ctx, state, target);
            })
          });
        };

        var eventToCursorPosition = function(evt){
          var rect = stage.getBoundingClientRect();
          return {
            x: (evt.clientX - rect.left) / (rect.right - rect.left) * stage.width,
            y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * stage.height
          };
        }

        var onDragStart = render;
        var onDragEnd = render;

        var onDragMove = createDragMoveHandler(states, render);

        var hitTest = function(evt, pos) {
          return states.reduce(function(prev, curr, idx) {
            return vecDistance(pos, curr.pos) < 80 ? idx : prev;
          }, null);
        };

        var dragState = setupDrag(stage, eventToCursorPosition, hitTest,onDragStart, onDragMove, onDragEnd);

        return function() {
          setStageSize(stage, 1200, 600);
          render();
        };
      }

      var renderer = setup(document.getElementById('stage'));
      renderer();
    </script>
	</body>
</html>
